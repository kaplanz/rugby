//! DMG-01: [Game Boy]
//!
//! [Game Boy]: https://en.wikipedia.org/wiki/Game_Boy

use std::cell::RefCell;
use std::rc::Rc;

use remus::bus::adapt::View;
use remus::bus::Bus;
use remus::{Block, Device, Machine};

use self::mem::Memory;
use self::mmio::Mmio;
use crate::dev::Unmapped;
use crate::emu::{screen, Emulator};
use crate::hw::cart::Cartridge;
use crate::hw::cpu::{Processor, Sm83 as Cpu};
use crate::hw::joypad::Joypad;
use crate::hw::pic::Pic;
use crate::hw::ppu::Ppu;
use crate::hw::timer::Timer;

mod boot;
mod mem;
mod mmio;

pub use crate::hw::cart;
pub use crate::hw::joypad::Button;
pub use crate::hw::ppu::Screen;

/// Screen info.
pub const SCREEN: screen::Info = screen::Info {
    width: 160,
    height: 144,
};

/// DMG-01 Game Boy emulator.
#[derive(Debug, Default)]
pub struct GameBoy {
    // State
    cycle: usize,
    // Devices
    cart: Cartridge,
    cpu: Cpu,
    joypad: Joypad,
    pic: Rc<RefCell<Pic>>,
    ppu: Ppu,
    timer: Timer,
    // Memory
    mem: Memory,
    mmio: Mmio,
    mmu: Rc<RefCell<Bus>>,
}

impl GameBoy {
    /// Constructs a new, reset `GameBoy`.
    ///
    /// This will call [`Block::reset`] before returning, allowing emulation to
    /// begin without further prior setup.
    pub fn new(cart: Cartridge) -> Self {
        let mut this = Self {
            cart,
            ..Default::default()
        };
        this.reset();
        this
    }

    #[rustfmt::skip]
    fn memmap(&mut self) {
        // Prepare MMU
        self.mmu.take();
        let mut mmu = self.mmu.borrow_mut();

        // Prepare devices
        let boot = self.mem.boot.clone();
        let rom  = self.cart.rom().clone();
        let vram = self.ppu.vram.clone();
        let eram = self.cart.ram().clone();
        let wram = self.mem.wram.clone();
        let echo = View::new(wram.clone(), 0x0000..=0x1dff).to_shared();
        let oam  = self.ppu.oam.clone();
        let mmio = self.mmio.bus.clone();
        let hram = self.mem.hram.clone();
        let pic  = self.pic.borrow().enable.clone();
        let unmapped = Unmapped::<0x10000>::new().to_shared();

        // Map devices in MMU  // ┌──────────┬────────────┬─────┐
                               // │   SIZE   │    NAME    │ DEV │
                               // ├──────────┼────────────┼─────┤
        mmu.map(0x0000, boot); // │    256 B │       Boot │ ROM │
        mmu.map(0x0000, rom);  // │  32 Ki B │  Cartridge │ ROM │
        mmu.map(0x8000, vram); // │   8 Ki B │      Video │ RAM │
        mmu.map(0xa000, eram); // │   8 Ki B │   External │ RAM │
        mmu.map(0xc000, wram); // │   8 Ki B │       Work │ RAM │
        mmu.map(0xe000, echo); // │   7680 B │       Echo │ RAM │
        mmu.map(0xfe00, oam);  // │    160 B │        OAM │ RAM │
                               // │     96 B │   Unmapped │ --- │
        mmu.map(0xff00, mmio); // │    128 B │        I/O │ Bus │
        mmu.map(0xff80, hram); // │    127 B │       High │ RAM │
        mmu.map(0xffff, pic);  // │      1 B │  Interrupt │ Reg │
                               // └──────────┴────────────┴─────┘
        // NOTE: use `Unmapped` as a fallback to report reads as `0xff`
        mmu.map(0x0000, unmapped);
    }
}

impl Block for GameBoy {
    #[rustfmt::skip]
    fn reset(&mut self) {
        // Reset CPU
        self.cpu.reset();
        self.cpu.set_bus(self.mmu.clone()); // link MMU to CPU

        // Reset cartridge
        self.cart.reset();

        // Re-map I/O
        self.mmio.con = self.joypad.con.clone();             // link I/O to joypad
        self.mmio.timer = self.timer.ctl.clone();           // link I/O to timer registers
        self.mmio.iflag = self.pic.borrow().active.clone();  // link I/O to IF register
        self.mmio.lcd = self.ppu.ctl.clone();                // link I/O to LCD controller
        self.mmio.boot = self.mem.boot.borrow().ctl.clone(); // link I/O to BOOT controller
        self.mmio.reset();

        // Reset memory
        self.mem.reset();

        // Reset interrupts
        self.pic.borrow_mut().reset();
        self.cpu.set_pic(self.pic.clone());    // link PIC to CPU
        self.joypad.set_pic(self.pic.clone()); // link PIC to joypad
        self.ppu.set_pic(self.pic.clone());    // link PIC to PPU
        self.timer.set_pic(self.pic.clone());  // link PIC to timer

        // Reset joypad
        self.joypad.reset();

        // Reset PPU
        self.ppu.set_bus(self.mmu.clone()); // link MMU to CPU
        self.ppu.reset();

        // Reset timer
        self.timer.reset();

        // Re-map MMU
        self.memmap();
    }
}

impl Emulator for GameBoy {
    type Input = Button;

    type Screen = Screen;

    fn send(&mut self, keys: Vec<Self::Input>) {
        self.joypad.input(keys);
    }

    fn redraw(&self, mut callback: impl FnMut(&Screen)) {
        if self.ppu.ready() {
            callback(self.ppu.screen())
        }
    }
}

impl Machine for GameBoy {
    fn enabled(&self) -> bool {
        self.cpu.enabled()
    }

    fn cycle(&mut self) {
        // CPU runs on a 1 MiHz clock: implement using a simple clock divider
        if self.cycle % 4 == 0 {
            // Wake disabled CPU if interrupts pending
            if !self.cpu.enabled() && self.pic.borrow().int().is_some() {
                self.cpu.wake();
            }
            // Cycle CPU if enabled
            if self.cpu.enabled() {
                self.cpu.cycle();
            }
        }

        // PPU runs on a 4 MiHz clock
        if self.ppu.enabled() {
            self.ppu.cycle();
        }

        // Timer runs on a 4 MiHz clock
        if self.timer.enabled() {
            self.timer.cycle();
        }

        // Keep track of cycles executed
        self.cycle = self.cycle.wrapping_add(1);
    }
}

#[cfg(test)]
mod tests {
    use remus::Device;

    use super::*;

    fn setup() -> GameBoy {
        // Define cartridge ROM
        let rom: [u8; 0x150] = [
            0xc3, 0x8b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x8b, 0x02, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xe1,
            0x5f, 0x16, 0x00, 0x19, 0x5e, 0x23, 0x56, 0xd5, 0xe1, 0xe9, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xfd, 0x01, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xc3, 0x12, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x12, 0x27, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xc3, 0x7e, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0xc3, 0x50, 0x01, 0xce, 0xed, 0x66, 0x66, 0xcc, 0x0d,
            0x00, 0x0b, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x08, 0x11, 0x1f,
            0x88, 0x89, 0x00, 0x0e, 0xdc, 0xcc, 0x6e, 0xe6, 0xdd, 0xdd, 0xd9, 0x99, 0xbb, 0xbb,
            0x67, 0x63, 0x6e, 0x0e, 0xec, 0xcc, 0xdd, 0xdc, 0x99, 0x9f, 0xbb, 0xb9, 0x33, 0x3e,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x02, 0x01, 0x00, 0x00, 0xdc, 0x31, 0xbb,
        ];
        let cart = Cartridge::new(&rom).unwrap();
        // Create a default GameBoy instance
        GameBoy::new(cart)
    }

    #[test]
    fn boot_disable_works() {
        let emu = setup();

        // Ensure boot ROM starts enabled:
        // - Perform comparison against boot ROM contents
        (0x0000..=0x0100)
            .map(|addr| emu.mmu.borrow().read(addr))
            .zip([
                0x31, 0xfe, 0xff, 0xaf, 0x21, 0xff, 0x9f, 0x32, 0xcb, 0x7c, 0x20, 0xfb, 0x21, 0x26,
                0xff, 0x0e, 0x11, 0x3e, 0x80, 0x32, 0xe2, 0x0c, 0x3e, 0xf3, 0xe2, 0x32, 0x3e, 0x77,
                0x77, 0x3e, 0xfc, 0xe0, 0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1a, 0xcd, 0x95,
                0x00, 0xcd, 0x96, 0x00, 0x13, 0x7b, 0xfe, 0x34, 0x20, 0xf3, 0x11, 0xd8, 0x00, 0x06,
                0x08, 0x1a, 0x13, 0x22, 0x23, 0x05, 0x20, 0xf9, 0x3e, 0x19, 0xea, 0x10, 0x99, 0x21,
                0x2f, 0x99, 0x0e, 0x0c, 0x3d, 0x28, 0x08, 0x32, 0x0d, 0x20, 0xf9, 0x2e, 0x0f, 0x18,
                0xf3, 0x67, 0x3e, 0x64, 0x57, 0xe0, 0x42, 0x3e, 0x91, 0xe0, 0x40, 0x04, 0x1e, 0x02,
                0x0e, 0x0c, 0xf0, 0x44, 0xfe, 0x90, 0x20, 0xfa, 0x0d, 0x20, 0xf7, 0x1d, 0x20, 0xf2,
                0x0e, 0x13, 0x24, 0x7c, 0x1e, 0x83, 0xfe, 0x62, 0x28, 0x06, 0x1e, 0xc1, 0xfe, 0x64,
                0x20, 0x06, 0x7b, 0xe2, 0x0c, 0x3e, 0x87, 0xe2, 0xf0, 0x42, 0x90, 0xe0, 0x42, 0x15,
                0x20, 0xd2, 0x05, 0x20, 0x4f, 0x16, 0x20, 0x18, 0xcb, 0x4f, 0x06, 0x04, 0xc5, 0xcb,
                0x11, 0x17, 0xc1, 0xcb, 0x11, 0x17, 0x05, 0x20, 0xf5, 0x22, 0x23, 0x22, 0x23, 0xc9,
                0xce, 0xed, 0x66, 0x66, 0xcc, 0x0d, 0x00, 0x0b, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0c,
                0x00, 0x0d, 0x00, 0x08, 0x11, 0x1f, 0x88, 0x89, 0x00, 0x0e, 0xdc, 0xcc, 0x6e, 0xe6,
                0xdd, 0xdd, 0xd9, 0x99, 0xbb, 0xbb, 0x67, 0x63, 0x6e, 0x0e, 0xec, 0xcc, 0xdd, 0xdc,
                0x99, 0x9f, 0xbb, 0xb9, 0x33, 0x3e, 0x3c, 0x42, 0xb9, 0xa5, 0xb9, 0xa5, 0x42, 0x3c,
                0x21, 0x04, 0x01, 0x11, 0xa8, 0x00, 0x1a, 0x13, 0xbe, 0x20, 0xfe, 0x23, 0x7d, 0xfe,
                0x34, 0x20, 0xf5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20, 0xfb, 0x86, 0x20, 0xfe,
                0x3e, 0x01, 0xe0, 0x50,
            ])
            .for_each(|(read, rom)| assert_eq!(read, rom));

        // Disable boot ROM
        emu.mmu.borrow_mut().write(0xff50, 0x01);

        // Check if disable was successful:
        // - Perform comparison against cartridge ROM contents
        (0x0000..=0x0100)
            .map(|addr| emu.mmu.borrow().read(addr))
            .zip([
                0xc3, 0x8b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x8b, 0x02, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xe1,
                0x5f, 0x16, 0x00, 0x19, 0x5e, 0x23, 0x56, 0xd5, 0xe1, 0xe9, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xfd, 0x01, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xc3, 0x12, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x12, 0x27, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xc3, 0x7e, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
                0xff, 0xff, 0xff, 0xff,
            ])
            .for_each(|(read, rom)| assert_eq!(read, rom));
    }

    #[test]
    fn mmu_all_works() {
        // NOTE: Test reads (and writes) for each component separately
        let emu = setup();

        // Cartridge ROM
        (0x0100..=0x7fff).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x20));
        assert!((0x0100..=0x7fff)
            .map(|addr| emu.cart.rom().borrow().read(addr))
            .any(|byte| byte != 0x20));
        // Video RAM
        (0x8000..=0x9fff).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x30));
        (0x0000..=0x1fff)
            .map(|addr| emu.ppu.vram.borrow().read(addr))
            .for_each(|byte| assert_eq!(byte, 0x30));
        // External RAM
        (0xa000..=0xbfff).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x40));
        (0x0000..=0x1fff)
            .map(|addr| emu.cart.ram().borrow().read(addr))
            .for_each(|byte| assert_eq!(byte, 0x40));
        // OAM RAM
        (0xfe00..=0xfe9f).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x50));
        (0x00..=0x9f)
            .map(|addr| emu.ppu.oam.borrow().read(addr))
            .for_each(|byte| assert_eq!(byte, 0x50));
        // I/O Bus
        {
            // Controller
            (0xff00..=0xff00).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x61));
            // NOTE: Only bits 0x30 are writable
            (0x00..=0x00)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0xef));
            (0x0..=0x0)
                .map(|addr| emu.mmio.con.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0xef));
            // Communication
            (0xff01..=0xff02).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x62));
            (0x01..=0x02)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x62));
            (0x00..=0x01)
                .map(|addr| emu.mmio.com.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x62));
            // Divider & Timer
            (0xff04..=0xff07).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x63));
            (0x04..=0x07)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x63));
            (0x00..=0x03)
                .map(|addr| emu.mmio.timer.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x63));
            // Interrupt Flag
            (0xff0f..=0xff0f).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x64));
            (0x0f..=0x0f)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x64));
            (0x0..=0x0)
                .map(|addr| emu.mmio.iflag.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x64));
            (0x0..=0x0)
                .map(|addr| emu.pic.borrow().active.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x64));
            // Sound
            (0xff10..=0xff26).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x65));
            (0x10..=0x26)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x65));
            (0x00..=0x16)
                .map(|addr| emu.mmio.sound.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x65));
            // Waveform RAM
            (0xff30..=0xff3f).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x66));
            (0x30..=0x3f)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x66));
            (0x00..=0x0f)
                .map(|addr| emu.mmio.wave.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x66));
            // LCD
            (0xff40..=0xff4b).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x67));
            (0x40..=0x4b)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x67));
            (0x00..=0x0b)
                .map(|addr| emu.mmio.lcd.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x67));
            (0x00..=0x0b)
                .map(|addr| emu.ppu.ctl.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x67));
            // Boot ROM Disable
            (0xff50..=0xff50).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x68));
            (0x50..=0x50)
                .map(|addr| emu.mmio.bus.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x68));
            (0x00..=0x00)
                .map(|addr| emu.mmio.boot.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x68));
            (0x00..=0x00)
                .map(|addr| emu.mem.boot.borrow().ctl.borrow().read(addr))
                .for_each(|byte| assert_eq!(byte, 0x68));
        }
        // High RAM
        (0xff80..=0xfffe).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x70));
        (0x00..=0x7e)
            .map(|addr| emu.mem.hram.borrow().read(addr))
            .for_each(|byte| assert_eq!(byte, 0x70));
        // Interrupt Enable
        (0xffff..=0xffff).for_each(|addr| emu.mmu.borrow_mut().write(addr, 0x80));
        (0x0..=0x0)
            .map(|addr| emu.pic.borrow().enable.borrow().read(addr))
            .for_each(|byte| assert_eq!(byte, 0x80));
    }

    #[test]
    #[should_panic]
    fn mmu_boot_write_panics() {
        let emu = setup();

        // Write to boot ROM (should panic)
        emu.mmu.borrow_mut().write(0x0000, 0xaa);
    }

    #[test]
    fn mmu_unmapped_works() {
        let emu = setup();

        // Disable boot ROM
        emu.mmu.borrow_mut().write(0xff50, 0x01);

        // Define unmapped addresses
        let unmapped = [0xfea0..=0xfeff, 0xff03..=0xff03, 0xff27..=0xff2f];

        // Test unmapped addresses
        for gap in unmapped {
            for addr in gap {
                // Write to every unmapped address
                emu.mmu.borrow_mut().write(addr, 0xaa);
                // Check the write didn't work
                assert_eq!(emu.mmu.borrow().read(addr), 0xff);
            }
        }
    }
}
