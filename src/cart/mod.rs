use std::cell::RefCell;
use std::cmp::Ordering;
use std::iter;
use std::rc::Rc;

use log::{debug, error, info};
use remus::dev::Null;
use remus::mem::{Memory, Ram, Rom};
use remus::{Block, Device};
use thiserror::Error;

use self::header::Header;
use self::mbc::{Mbc, Mbc1, NoMbc};
use crate::cart::header::CartridgeType;

mod header;
mod mbc;

#[derive(Debug)]
pub struct Cartridge {
    header: Header,
    mbc: Box<dyn Mbc>,
}

impl Cartridge {
    pub fn new(rom: &[u8]) -> Result<Cartridge, Error> {
        // Parse cartridge header
        let header = Header::try_from(&*rom)?;
        info!("Cartridge:\n{header}");

        // Construct null device (for reuse where needed)
        let null = Rc::new(RefCell::new(Null::<0>::new()));

        // Prepare external ROM
        let rom = {
            // Calculate buffer stats
            let read = rom.len();
            match read.cmp(&header.romsz) {
                Ordering::Less => {
                    let diff = header.romsz - read;
                    error!("Read {read} bytes; remaining {diff} byte(s) uninitialized.")
                }
                Ordering::Equal => info!("Read {read} bytes."),
                Ordering::Greater => {
                    let diff = read - header.romsz;
                    error!("Read {read} bytes; remaining {diff} byte(s) truncated.")
                }
            }
            rom.iter()
                .cloned()
                .chain(iter::repeat(0u8))
                .take(header.romsz)
                .collect::<Vec<_>>()
        };
        debug!("ROM:\n{}", &rom as &dyn Memory);

        // Construct external ROM
        let erom: Rc<RefCell<dyn Device>> = {
            let rom: Box<[_]> = rom.into();
            match header.romsz {
                0x8000 => Rc::new(RefCell::new(Rom::<0x8000>::from(
                    &*Box::<[_; 0x8000]>::try_from(rom).unwrap(),
                ))),
                0x10000 => Rc::new(RefCell::new(Rom::<0x10000>::from(
                    &*Box::<[_; 0x10000]>::try_from(rom).unwrap(),
                ))),
                0x20000 => Rc::new(RefCell::new(Rom::<0x20000>::from(
                    &*Box::<[_; 0x20000]>::try_from(rom).unwrap(),
                ))),
                0x40000 => Rc::new(RefCell::new(Rom::<0x40000>::from(
                    &*Box::<[_; 0x40000]>::try_from(rom).unwrap(),
                ))),
                0x80000 => Rc::new(RefCell::new(Rom::<0x80000>::from(
                    &*Box::<[_; 0x80000]>::try_from(rom).unwrap(),
                ))),
                0x100000 => Rc::new(RefCell::new(Rom::<0x100000>::from(
                    &*Box::<[_; 0x100000]>::try_from(rom).unwrap(),
                ))),
                0x200000 => Rc::new(RefCell::new(Rom::<0x200000>::from(
                    &*Box::<[_; 0x200000]>::try_from(rom).unwrap(),
                ))),
                0x400000 => Rc::new(RefCell::new(Rom::<0x400000>::from(
                    &*Box::<[_; 0x400000]>::try_from(rom).unwrap(),
                ))),
                0x800000 => Rc::new(RefCell::new(Rom::<0x800000>::from(
                    &*Box::<[_; 0x800000]>::try_from(rom).unwrap(),
                ))),
                _ => unreachable!(),
            }
        };

        // Construct external RAM
        let eram: Rc<RefCell<dyn Device>> = match header.ramsz {
            0x0 => null.clone(),
            0x2000 => Rc::new(RefCell::new(Ram::<0x2000>::new())),
            0x8000 => Rc::new(RefCell::new(Ram::<0x8000>::new())),
            0x20000 => Rc::new(RefCell::new(Ram::<0x20000>::new())),
            0x10000 => Rc::new(RefCell::new(Ram::<0x10000>::new())),
            _ => unreachable!(),
        };

        // Construct a cartridge
        let mbc: Box<dyn Mbc> = match header.cart {
            CartridgeType::Rom { ram, .. } => {
                let eram = [null, eram][ram as usize].clone();
                Box::new(NoMbc::with(erom, eram))
            }
            CartridgeType::Mbc1 { ram, battery } => {
                let eram = [null, eram][ram as usize].clone();
                Box::new(Mbc1::with(erom, eram, battery))
            }
            cart => unimplemented!("{cart:?}"),
        };

        Ok(Self { header, mbc })
    }

    /// Get a reference to the cartridge's header.
    pub fn header(&self) -> &Header {
        &self.header
    }

    pub fn rom(&self) -> Rc<RefCell<dyn Device>> {
        self.mbc.rom()
    }

    pub fn ram(&self) -> Rc<RefCell<dyn Device>> {
        self.mbc.ram()
    }
}

impl Block for Cartridge {
    fn reset(&mut self) {
        self.mbc.reset();
    }
}

impl Default for Cartridge {
    fn default() -> Self {
        let rom = [
            0xc3, 0x8b, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x8b, 0x02, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x87, 0xe1,
            0x5f, 0x16, 0x00, 0x19, 0x5e, 0x23, 0x56, 0xd5, 0xe1, 0xe9, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0xfd, 0x01, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xc3, 0x12, 0x27, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x12, 0x27, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xc3, 0x7e, 0x01, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
            0xff, 0xff, 0xff, 0xff, 0x00, 0xc3, 0x50, 0x01, 0xce, 0xed, 0x66, 0x66, 0xcc, 0x0d,
            0x00, 0x0b, 0x03, 0x73, 0x00, 0x83, 0x00, 0x0c, 0x00, 0x0d, 0x00, 0x08, 0x11, 0x1f,
            0x88, 0x89, 0x00, 0x0e, 0xdc, 0xcc, 0x6e, 0xe6, 0xdd, 0xdd, 0xd9, 0x99, 0xbb, 0xbb,
            0x67, 0x63, 0x6e, 0x0e, 0xec, 0xcc, 0xdd, 0xdc, 0x99, 0x9f, 0xbb, 0xb9, 0x33, 0x3e,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0xe6, 0x31, 0xbb,
        ];
        Self::new(&rom).unwrap()
    }
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("could not parse ROM header")]
    Header(#[from] header::Error),
}
